<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TinyTail - Log Viewer</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%231e1e1e' width='100' height='100'/%3E%3Cpath d='M20 25h45' stroke='%234ec9b0' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M20 40h60' stroke='%234ec9b0' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M20 55h50' stroke='%234ec9b0' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M20 70h35' stroke='%2358d1b3' stroke-width='5' stroke-linecap='round'/%3E%3Ccircle cx='62' cy='70' r='3' fill='%2358d1b3'/%3E%3Ccircle cx='70' cy='70' r='3' fill='%2358d1b3'/%3E%3Ccircle cx='78' cy='70' r='3' fill='%2358d1b3'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        vscode: {
                            bg: '#1e1e1e',
                            panel: '#252526',
                            border: '#333',
                            text: '#d4d4d4',
                            accent: '#4ec9b0',
                            blue: '#569cd6',
                            comment: '#858585',
                        }
                    }
                }
            }
        }
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
    <style>
        [x-cloak] { display: none !important; }
        .log-message {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 12px;
        }
        .log-entry {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.25rem 0.75rem;
            border-bottom: 1px solid #2d2d2d;
            font-size: 12px;
            line-height: 1.5;
        }
        .log-entry:hover {
            background-color: #252526;
        }
        .log-timestamp {
            color: #858585;
            min-width: 120px;
            flex-shrink: 0;
            cursor: pointer;
            transition: color 0.2s;
        }
        .log-timestamp:hover {
            color: #4ec9b0;
            text-decoration: underline;
        }
        .log-level {
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-weight: bold;
            font-size: 10px;
            min-width: 50px;
            text-align: center;
            flex-shrink: 0;
        }
        .log-source {
            color: #569cd6;
            min-width: 100px;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .log-logger {
            color: #dcdcaa;
            width: 250px;
            overflow: hidden;
            white-space: nowrap;
            flex-shrink: 0;
            text-overflow: ellipsis;
        }
        .log-message-wrapper {
            flex: 1;
            overflow: hidden;
        }
    </style>
</head>
<body class="bg-vscode-bg text-vscode-text font-mono text-sm">
    <div x-data="logViewer()" x-cloak class="p-5">
        <!-- Header -->
        <div class="flex justify-between items-center mb-5 pb-3 border-b border-vscode-border">
            <h1 class="text-2xl font-bold text-vscode-accent">TinyTail</h1>
            <div class="flex items-center gap-4">
                <span x-text="statusMessage" class="text-vscode-comment text-xs"></span>
                <button @click="logout" class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded transition">
                    Logout
                </button>
            </div>
        </div>
        <!-- Controls -->
        <div class="bg-vscode-panel p-4 rounded mb-5">
            <!-- Search & DateTime -->
            <div class="flex flex-wrap gap-2">
                <input type="text" x-model="searchQuery" @keydown.enter="performSearch" :disabled="loading" placeholder="Search logs..." class="flex-1 min-w-[200px] bg-gray-700 border border-vscode-border text-vscode-text px-3 py-2 rounded focus:ring-2 focus:ring-vscode-accent focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed">
                <input type="datetime-local" x-model="searchDateTime" :disabled="loading" class="bg-gray-700 border border-vscode-border text-vscode-text px-3 py-2 rounded focus:ring-2 focus:ring-vscode-accent focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed" step="60">
                <button @click="performSearch" :disabled="loading" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded transition disabled:opacity-50 disabled:cursor-not-allowed">
                    <span x-show="!loading">Search</span>
                    <span x-show="loading">Searching...</span>
                </button>
                <button @click="clearSearch" :disabled="loading" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded transition disabled:opacity-50 disabled:cursor-not-allowed">
                    Clear
                </button>
            </div>
        </div>
        <!-- Error Message -->
        <div x-show="errorMessage" x-transition class="bg-red-900/50 border border-red-600 text-red-300 px-4 py-3 rounded mb-4">
            <span x-text="errorMessage"></span>
        </div>
        <!-- Logs Container -->
        <div x-ref="logsContainer" @scroll="handleScroll" class="border border-vscode-border rounded overflow-auto" style="max-height: calc(100vh - 250px);">
            <!-- All search results loaded indicator -->
            <div x-show="isSearchMode && !hasMoreSearchResults && !loadingOlder && logs.length > 0" class="text-center py-2 text-vscode-comment text-xs bg-vscode-panel border-b border-vscode-border">
                All matching results loaded
            </div>
            <!-- Loading older logs indicator -->
            <div x-show="loadingOlder" class="text-center py-2 text-vscode-comment text-xs bg-vscode-panel">
                Loading older logs...
            </div>
            <!-- Loading State -->
            <div x-show="loading && logs.length === 0" class="text-center py-10 text-vscode-comment">
                Loading logs...
            </div>
            <!-- Empty State -->
            <div x-show="!loading && logs.length === 0" class="text-center py-10 text-vscode-comment">
                No logs found. Logs will appear here automatically.
            </div>
            <!-- Log Entries -->
            <template x-for="log in logs" :key="log.cursor">
                <div class="log-entry">
                    <span class="log-timestamp" @click="searchByTimestamp(log.timestamp)" x-text="formatTimestamp(log.timestamp)"></span>
                    <span
                        :class="{
                            'bg-gray-700 text-gray-400': log.level === 'DEBUG',
                            'bg-green-900 text-green-300': log.level === 'INFO',
                            'bg-yellow-900 text-yellow-300': log.level === 'WARN',
                            'bg-red-900 text-red-300': log.level === 'ERROR'
                        }"
                        class="log-level"
                        x-text="log.level"
                    ></span>
                    <span class="log-source" x-text="log.source"></span>
                    <span class="log-logger" :title="log.logger || ''" x-text="abbreviateLogger(log.logger)"></span>
                    <div class="log-message-wrapper">
                        <div class="log-message text-vscode-text" x-text="log.message"></div>
                    </div>
                </div>
            </template>
            <!-- Loading newer logs indicator -->
            <div x-show="loadingNewer" class="text-center py-2 text-vscode-comment text-xs bg-vscode-panel">
                Loading newer logs...
            </div>
        </div>
        <!-- Status bar -->
        <div class="mt-2 text-center text-vscode-comment text-xs">
            <span x-show="liveTailActive" class="text-green-400">‚óè Live</span>
            <span x-show="!liveTailActive && !isSearchMode">
                <a href="#" @click.prevent="scrollToBottom" class="text-vscode-accent hover:underline">Scroll to Latest</a>
            </span>
        </div>
    </div>
    <script>
        // Detect base path from current URL (handles API Gateway stages and custom domains)
        function getBasePath() {
            const path = window.location.pathname;
            // If we're at /, base is empty (custom domain)
            // If we're at /prod/ or /stage/, extract the base (API Gateway)
            if (path === '/') {
                return '';
            }
            // Remove trailing slash to get the base path
            return path.replace(/\/$/, '');
        }

        function logViewer() {
            return {
                logs: [],
                loading: false,
                loadingOlder: false,
                loadingNewer: false,
                liveTailActive: false,
                liveTailInterval: null,
                searchQuery: '',
                searchDateTime: '',
                errorMessage: '',
                statusMessage: '',
                basePath: getBasePath(),
                isSearchMode: false,
                isDateTimeSearch: false,
                hasMoreSearchResults: false,
                searchStartTime: '',
                searchEndTime: '',
                lastScrollTop: 0,
                isProgrammaticScroll: false,

                init() {
                    // Auto-start live tail on page load
                    this.startLiveTail();
                },

                async loadLatestLogs() {
                    const isFirstLoad = this.logs.length === 0;
                    this.loading = isFirstLoad; // Only show loading if no logs yet
                    this.errorMessage = '';

                    try {
                        let url;
                        if (isFirstLoad) {
                            // On first load, get the latest 200 logs
                            url = `${this.basePath}/logs/latest?limit=200`;
                        } else {
                            // On subsequent polls, only get logs after the newest one we have
                            const newestCursor = this.logs[this.logs.length - 1].cursor;
                            url = `${this.basePath}/logs?limit=200&after=${newestCursor}`;
                        }

                        const response = await fetch(url);
                        if (response.status === 302 || response.redirected) {
                            window.location.href = `${this.basePath}/login`;
                            return;
                        }
                        if (!response.ok) throw new Error('Failed to load logs');

                        let data = await response.json();

                        // If live tail was stopped while fetching (user scrolled up), ignore results
                        // Exception: always process first load
                        if (!this.liveTailActive && !isFirstLoad) {
                            return;
                        }

                        if (data && data.length > 0) {
                            if (isFirstLoad) {
                                // First load uses /logs/latest which returns newest-first, so reverse
                                data.reverse();
                                this.logs = data;
                            } else {
                                // Subsequent polls use /logs?after=X which returns chronological order (oldest-first)
                                // Append directly without reversing
                                this.logs = [...this.logs, ...data];
                            }

                            this.statusMessage = `Last updated: ${new Date().toLocaleTimeString()}`;

                            // Auto-scroll to bottom (only happens if live tail active or first load)
                            this.$nextTick(() => {
                                this.scrollToBottom();
                            });
                        }
                    } catch (error) {
                        this.errorMessage = error.message;
                        this.statusMessage = 'Error loading logs';
                    } finally {
                        this.loading = false;
                    }
                },

                async loadOlderLogs() {
                    if (this.logs.length === 0 || this.loadingOlder) return;

                    // Get the oldest log (first in array since reversed)
                    const oldestCursor = this.logs[0].cursor;
                    this.loadingOlder = true;

                    // Remember scroll position
                    const container = this.$refs.logsContainer;
                    const oldScrollHeight = container.scrollHeight;

                    try {
                        const response = await fetch(`${this.basePath}/logs?limit=100&before=${oldestCursor}`);
                        if (!response.ok) throw new Error('Failed to load older logs');

                        let data = await response.json();
                        if (data && data.length > 0) {
                            // Backend returns chronological order (oldest first) - no need to reverse
                            this.logs = [...data, ...this.logs];

                            // Maintain scroll position
                            this.$nextTick(() => {
                                const newScrollHeight = container.scrollHeight;
                                container.scrollTop = newScrollHeight - oldScrollHeight;
                            });
                        }
                    } catch (error) {
                        this.errorMessage = error.message;
                    } finally {
                        this.loadingOlder = false;
                    }
                },

                async loadOlderSearchResults() {
                    if (this.logs.length === 0 || this.loadingOlder || !this.hasMoreSearchResults) return;

                    // Get the oldest log (first in array since reversed)
                    const oldestCursor = this.logs[0].cursor;
                    this.loadingOlder = true;

                    // Remember scroll position
                    const container = this.$refs.logsContainer;
                    const oldScrollHeight = container.scrollHeight;

                    try {
                        // Request 201 to check if there are more
                        const url = `${this.basePath}/logs/search?q=${encodeURIComponent(this.searchQuery)}&limit=201&before=${oldestCursor}&start=${encodeURIComponent(this.searchStartTime)}&end=${encodeURIComponent(this.searchEndTime)}`;
                        const response = await fetch(url);
                        if (!response.ok) throw new Error('Failed to load older search results');

                        let data = await response.json();
                        if (data && data.length > 0) {
                            // Check if there are more results beyond this batch
                            if (data.length > 200) {
                                this.hasMoreSearchResults = true;
                                data = data.slice(0, 200);
                            } else {
                                this.hasMoreSearchResults = false;
                            }

                            // Reverse and prepend to beginning of array
                            data.reverse();
                            this.logs = [...data, ...this.logs];

                            // Maintain scroll position
                            this.$nextTick(() => {
                                const newScrollHeight = container.scrollHeight;
                                container.scrollTop = newScrollHeight - oldScrollHeight;
                            });
                        } else {
                            // No more results
                            this.hasMoreSearchResults = false;
                        }
                    } catch (error) {
                        this.errorMessage = error.message;
                    } finally {
                        this.loadingOlder = false;
                    }
                },

                async loadOlderDateTimeLogs() {
                    if (this.logs.length === 0 || this.loadingOlder) return;

                    // Get the oldest log (first in array)
                    const oldestCursor = this.logs[0].cursor;
                    this.loadingOlder = true;

                    // Remember scroll position
                    const container = this.$refs.logsContainer;
                    const oldScrollHeight = container.scrollHeight;

                    try {
                        const response = await fetch(`${this.basePath}/logs?limit=100&before=${oldestCursor}`);
                        if (!response.ok) throw new Error('Failed to load older logs');

                        let data = await response.json();

                        // Only append if we're still in datetime search mode (prevents race condition with Clear)
                        if (this.isDateTimeSearch && data && data.length > 0) {
                            // Backend returns chronological order (oldest first) - no need to reverse
                            this.logs = [...data, ...this.logs];

                            // Maintain scroll position
                            this.$nextTick(() => {
                                const newScrollHeight = container.scrollHeight;
                                container.scrollTop = newScrollHeight - oldScrollHeight;
                            });
                        }
                    } catch (error) {
                        this.errorMessage = error.message;
                    } finally {
                        this.loadingOlder = false;
                    }
                },

                async loadNewerDateTimeLogs() {
                    if (this.logs.length === 0 || this.loadingNewer) return;

                    // Get the newest log (last in array)
                    const newestCursor = this.logs[this.logs.length - 1].cursor;
                    this.loadingNewer = true;

                    try {
                        const response = await fetch(`${this.basePath}/logs?limit=100&after=${newestCursor}`);
                        if (!response.ok) throw new Error('Failed to load newer logs');

                        let data = await response.json();

                        // Only append if we're still in datetime search mode (prevents race condition with Clear)
                        if (this.isDateTimeSearch && data && data.length > 0) {
                            // Backend returns chronological order (oldest first), append directly
                            this.logs = [...this.logs, ...data];
                        } else if (this.isDateTimeSearch && (!data || data.length === 0)) {
                            // No more newer logs - we've caught up to present, switch to live tail
                            this.searchDateTime = '';
                            this.isSearchMode = false;
                            this.isDateTimeSearch = false;
                            this.logs = []; // Clear old search results
                            this.startLiveTail();
                        }
                    } catch (error) {
                        this.errorMessage = error.message;
                    } finally {
                        this.loadingNewer = false;
                    }
                },

                async performSearch() {
                    this.stopLiveTail();
                    this.isSearchMode = true;
                    this.isDateTimeSearch = false;

                    if (!this.searchQuery && !this.searchDateTime) {
                        this.isSearchMode = false;
                        this.isDateTimeSearch = false;
                        this.startLiveTail();
                        return;
                    }

                    this.loading = true;
                    this.errorMessage = '';
                    this.hasMoreSearchResults = false;

                    try {
                        let data;
                        let targetTimestamp = null;

                        if (this.searchDateTime) {
                            this.isDateTimeSearch = true;
                            targetTimestamp = new Date(this.searchDateTime).toISOString();
                            const response = await fetch(`${this.basePath}/logs/datetime?timestamp=${encodeURIComponent(targetTimestamp)}`);
                            if (!response.ok) throw new Error('Search failed');
                            data = await response.json();
                            const displayTime = new Date(this.searchDateTime).toLocaleString();
                            this.statusMessage = `Found ${data?.length || 0} logs around ${displayTime}`;

                            // Data is in chronological order from backend (oldest first)
                            // Keep it that way - don't reverse
                        } else {
                            // Request 201 to check if there are more
                            const response = await fetch(`${this.basePath}/logs/search?q=${encodeURIComponent(this.searchQuery)}&limit=201`);
                            if (!response.ok) throw new Error('Search failed');
                            data = await response.json();

                            // Store search time range for pagination
                            this.searchStartTime = new Date(Date.now() - 24*60*60*1000).toISOString(); // Default: last 24h
                            this.searchEndTime = new Date().toISOString();

                            // If we got 201 results, there may be more
                            if (data && data.length > 200) {
                                this.hasMoreSearchResults = true;
                                data = data.slice(0, 200); // Keep only first 200
                            } else {
                                this.hasMoreSearchResults = false;
                            }

                            this.statusMessage = `Found ${data?.length || 0} results${this.hasMoreSearchResults ? ' (scroll up for more)' : ''}`;

                            // Reverse so newest is at bottom for text search
                            if (data && data.length > 0) {
                                data.reverse();
                            }
                        }

                        this.logs = data || [];

                        // Scroll based on search type
                        this.$nextTick(() => {
                            // Set flag to ignore the scroll event from programmatic scrolling
                            this.isProgrammaticScroll = true;

                            if (targetTimestamp && this.logs.length > 0) {
                                // For datetime search, scroll to the log closest to target time
                                this.scrollToClosestLog(targetTimestamp);
                            } else {
                                // For text search, scroll to bottom
                                this.scrollToBottom();
                            }
                        });
                    } catch (error) {
                        this.errorMessage = error.message;
                        this.statusMessage = 'Error searching logs';
                    } finally {
                        this.loading = false;
                    }
                },

                clearSearch() {
                    this.searchQuery = '';
                    this.searchDateTime = '';
                    this.isSearchMode = false;
                    this.isDateTimeSearch = false;
                    // Clear the logs array so loadLatestLogs treats it as first load
                    this.logs = [];
                    this.startLiveTail();
                },

                searchByTimestamp(timestamp) {
                    // Convert ISO timestamp to datetime-local format (YYYY-MM-DDTHH:mm)
                    const date = new Date(timestamp);
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    const formattedDateTime = `${year}-${month}-${day}T${hours}:${minutes}`;

                    // Clear text search and set datetime search
                    this.searchQuery = '';
                    this.searchDateTime = formattedDateTime;

                    // Perform the datetime search
                    this.performSearch();
                },

                handleScroll() {
                    // Ignore programmatic scrolls (from search positioning)
                    if (this.isProgrammaticScroll) {
                        this.isProgrammaticScroll = false;
                        return;
                    }

                    const container = this.$refs.logsContainer;
                    const currentScrollTop = container.scrollTop;
                    const atBottom = this.isScrolledToBottom();
                    const scrollingUp = currentScrollTop < this.lastScrollTop;
                    const scrollingDown = currentScrollTop > this.lastScrollTop;
                    const nearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;

                    // Skip auto-loading on first scroll event (lastScrollTop === 0 and we've scrolled somewhere)
                    // This prevents initial scroll positioning from triggering loads
                    const isFirstScroll = this.lastScrollTop === 0 && currentScrollTop > 0;

                    // Handle infinite scroll based on mode (but not on first scroll)
                    if (!isFirstScroll && scrollingUp && currentScrollTop < 100) {
                        if (this.isDateTimeSearch) {
                            // In datetime search mode: load older logs
                            this.loadOlderDateTimeLogs();
                        } else if (this.isSearchMode) {
                            // In text search mode: load older search results if available
                            this.loadOlderSearchResults();
                        } else {
                            // In normal mode: load older logs
                            this.loadOlderLogs();
                        }
                    }

                    // Handle scrolling down to load newer logs (only for datetime search, and not on first scroll)
                    if (!isFirstScroll && this.isDateTimeSearch && scrollingDown && nearBottom) {
                        this.loadNewerDateTimeLogs();
                    }

                    // Update last scroll position
                    this.lastScrollTop = currentScrollTop;

                    // Only pause live tail if user actively scrolled UP (and not in search mode)
                    // Don't pause just from being not-at-bottom (could be from DOM changes)
                    if (!this.isSearchMode) {
                        if (scrollingUp && !atBottom && this.liveTailActive) {
                            this.stopLiveTail();
                        } else if (atBottom && !this.liveTailActive) {
                            this.startLiveTail();
                        }
                    }
                },

                isScrolledToBottom() {
                    const container = this.$refs.logsContainer;
                    if (!container) return true;
                    const threshold = 100; // pixels from bottom
                    return container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
                },

                scrollToBottom() {
                    const container = this.$refs.logsContainer;
                    if (container) {
                        container.scrollTop = container.scrollHeight;
                    }
                },

                scrollToClosestLog(targetTimestamp) {
                    const container = this.$refs.logsContainer;
                    if (!container || this.logs.length === 0) return;

                    const targetTime = new Date(targetTimestamp).getTime();

                    // Find the log closest to the target time
                    let closestIndex = 0;
                    let smallestDiff = Math.abs(new Date(this.logs[0].timestamp).getTime() - targetTime);

                    for (let i = 1; i < this.logs.length; i++) {
                        const diff = Math.abs(new Date(this.logs[i].timestamp).getTime() - targetTime);
                        if (diff < smallestDiff) {
                            smallestDiff = diff;
                            closestIndex = i;
                        }
                    }

                    // Get all log entry elements
                    const logEntries = container.querySelectorAll('.log-entry');
                    if (logEntries.length > closestIndex) {
                        const targetElement = logEntries[closestIndex];

                        // Calculate position to center the element
                        const elementTop = targetElement.offsetTop;
                        const elementHeight = targetElement.offsetHeight;
                        const containerHeight = container.clientHeight;

                        // Scroll to center the element in the viewport
                        container.scrollTop = elementTop - (containerHeight / 2) + (elementHeight / 2);
                    }
                },

                startLiveTail() {
                    if (this.liveTailActive) return; // Already active

                    this.liveTailActive = true;
                    this.loadLatestLogs();
                    this.liveTailInterval = setInterval(() => {
                        this.loadLatestLogs();
                    }, 3000);
                },

                stopLiveTail() {
                    this.liveTailActive = false;
                    if (this.liveTailInterval) {
                        clearInterval(this.liveTailInterval);
                        this.liveTailInterval = null;
                    }
                },

                async logout() {
                    try {
                        await fetch(`${this.basePath}/auth/logout`, { method: 'POST' });
                        window.location.href = `${this.basePath}/login`;
                    } catch (error) {
                        this.errorMessage = 'Logout failed';
                    }
                },

                formatTimestamp(timestamp) {
                    // Format as "Nov 08 HH:MM:SS"
                    const date = new Date(timestamp);
                    const month = date.toLocaleDateString('en-US', { month: 'short' });
                    const day = String(date.getDate()).padStart(2, '0');
                    const time = date.toLocaleTimeString('en-US', {
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    return `${month} ${day} ${time}`;
                },

                abbreviateLogger(logger) {
                    if (!logger) return '';

                    // Split by dots: org.springframework.data.SomeClass
                    const parts = logger.split('.');

                    // If only one part (no package), return as-is
                    if (parts.length <= 1) return logger;

                    // Abbreviate all parts except the last one
                    const abbreviated = parts.slice(0, -1).map(part => part.charAt(0)).join('.');
                    const className = parts[parts.length - 1];

                    return abbreviated + '.' + className;
                }
            };
        }
    </script>
</body>
</html>