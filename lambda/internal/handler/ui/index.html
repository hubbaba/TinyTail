<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TinyTail - Log Viewer</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%231e1e1e' width='100' height='100'/%3E%3Cpath d='M20 25h45' stroke='%234ec9b0' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M20 40h60' stroke='%234ec9b0' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M20 55h50' stroke='%234ec9b0' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M20 70h35' stroke='%2358d1b3' stroke-width='5' stroke-linecap='round'/%3E%3Ccircle cx='62' cy='70' r='3' fill='%2358d1b3'/%3E%3Ccircle cx='70' cy='70' r='3' fill='%2358d1b3'/%3E%3Ccircle cx='78' cy='70' r='3' fill='%2358d1b3'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        vscode: {
                            bg: '#1e1e1e',
                            panel: '#252526',
                            border: '#333',
                            text: '#d4d4d4',
                            accent: '#4ec9b0',
                            blue: '#569cd6',
                            comment: '#858585',
                            button: '#0e639c',
                            'button-foreground': '#ffffff',
                            'button-hover': '#1177bb',
                        }
                    }
                }
            }
        }
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
    <style>
        [x-cloak] { display: none !important; }
        .log-message {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 12px;
        }
        .log-entry {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.25rem 0.75rem;
            border-bottom: 1px solid #2d2d2d;
            font-size: 12px;
            line-height: 1.5;
        }
        .log-entry:hover {
            background-color: #252526;
        }
        .log-timestamp {
            color: #858585;
            min-width: 120px;
            flex-shrink: 0;
            cursor: pointer;
            transition: color 0.2s;
        }
        .log-timestamp:hover {
            color: #4ec9b0;
            text-decoration: underline;
        }
        .log-level {
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-weight: bold;
            font-size: 10px;
            min-width: 50px;
            text-align: center;
            flex-shrink: 0;
        }
        .log-source {
            color: #569cd6;
            min-width: 100px;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .log-logger {
            color: #dcdcaa;
            width: 250px;
            overflow: hidden;
            white-space: nowrap;
            flex-shrink: 0;
            text-overflow: ellipsis;
        }
        .log-message-wrapper {
            flex: 1;
            overflow: hidden;
        }
    </style>
</head>
<body class="bg-vscode-bg text-vscode-text font-mono text-sm">
    <div x-data="logViewer()" x-cloak class="p-5">
        <!-- Header -->
        <div class="flex justify-between items-center mb-5 pb-3 border-b border-vscode-border">
            <h1 class="text-2xl font-bold text-vscode-accent">TinyTail</h1>
            <div class="flex items-center gap-4">
                <span x-text="statusMessage" class="text-vscode-comment text-xs"></span>
                <button @click="logout" class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded transition">
                    Logout
                </button>
            </div>
        </div>
        <!-- Controls -->
        <div class="bg-vscode-panel p-4 rounded mb-5">
            <!-- Search & DateTime -->
            <div class="flex flex-wrap gap-2">
                <input type="text" x-model="searchQuery" @keydown.enter="performSearch" :disabled="loading" placeholder="Search logs..." class="flex-1 min-w-[200px] bg-gray-700 border border-vscode-border text-vscode-text px-3 py-2 rounded focus:ring-2 focus:ring-vscode-accent focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed">
                <input type="datetime-local" x-model="searchDateTime" :disabled="loading" class="bg-gray-700 border border-vscode-border text-vscode-text px-3 py-2 rounded focus:ring-2 focus:ring-vscode-accent focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed" step="60">
                <button @click="performSearch" :disabled="loading" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded transition disabled:opacity-50 disabled:cursor-not-allowed">
                    <span x-show="!loading">Search</span>
                    <span x-show="loading">Searching...</span>
                </button>
                <button @click="clearSearch" :disabled="loading" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded transition disabled:opacity-50 disabled:cursor-not-allowed">
                    Clear
                </button>
            </div>
        </div>
        <!-- Error Message -->
        <div x-show="errorMessage" x-transition class="bg-red-900/50 border border-red-600 text-red-300 px-4 py-3 rounded mb-4">
            <span x-text="errorMessage"></span>
        </div>
        <!-- Logs Container -->
        <div x-ref="logsContainer" @scroll="handleScroll" class="border border-vscode-border rounded overflow-auto" style="max-height: calc(100vh - 250px);">
            <!-- All search results loaded indicator -->
            <div x-show="isSearchMode && !hasMoreSearchResults && !loadingOlder && logs.length > 0" class="text-center py-2 text-vscode-comment text-xs bg-vscode-panel border-b border-vscode-border">
                All matching results loaded
            </div>
            <!-- Loading older logs indicator -->
            <div x-show="loadingOlder" class="text-center py-2 text-vscode-comment text-xs bg-vscode-panel">
                Loading older logs...
            </div>
            <!-- Loading State -->
            <div x-show="loading && logs.length === 0" class="text-center py-10 text-vscode-comment">
                Loading logs...
            </div>
            <!-- Empty State with Load More option for search -->
            <div x-show="!loading && logs.length === 0 && isSearchMode && hasMoreSearchResults" class="text-center py-10">
                <div class="text-vscode-comment mb-4">
                    No matching logs found yet.
                </div>
                <button
                    @click="loadOlderSearchResults()"
                    :disabled="loadingOlder"
                    class="px-4 py-2 bg-vscode-button text-vscode-button-foreground hover:bg-vscode-button-hover disabled:opacity-50 disabled:cursor-not-allowed rounded"
                    x-text="loadingOlder ? 'Searching older logs...' : 'Search logs before ' + getContinuationTimestamp()">
                </button>
            </div>
            <!-- Empty State (no search or no more results) -->
            <div x-show="!loading && logs.length === 0 && (!isSearchMode || !hasMoreSearchResults)" class="text-center py-10 text-vscode-comment">
                No logs found. Logs will appear here automatically.
            </div>
            <!-- Log Entries -->
            <template x-for="log in logs" :key="log.cursor">
                <div class="log-entry">
                    <span class="log-timestamp" @click="searchByTimestamp(log.timestamp)" x-text="formatTimestamp(log.timestamp)"></span>
                    <span
                        :class="{
                            'bg-gray-700 text-gray-400': log.level === 'DEBUG',
                            'bg-green-900 text-green-300': log.level === 'INFO',
                            'bg-yellow-900 text-yellow-300': log.level === 'WARN',
                            'bg-red-900 text-red-300': log.level === 'ERROR'
                        }"
                        class="log-level"
                        x-text="log.level"
                    ></span>
                    <span class="log-source" x-text="log.source"></span>
                    <span class="log-logger" :title="log.logger || ''" x-text="abbreviateLogger(log.logger)"></span>
                    <div class="log-message-wrapper">
                        <div class="log-message text-vscode-text" x-text="log.message"></div>
                    </div>
                </div>
            </template>
            <!-- Loading newer logs indicator -->
            <div x-show="loadingNewer" class="text-center py-2 text-vscode-comment text-xs bg-vscode-panel">
                Loading newer logs...
            </div>
        </div>
        <!-- Status bar -->
        <div class="mt-2 text-center text-vscode-comment text-xs">
            <span x-show="liveTailActive" class="text-green-400">‚óè Live</span>
            <span x-show="!liveTailActive && !isSearchMode">
                <a href="#" @click.prevent="scrollToBottom" class="text-vscode-accent hover:underline">Scroll to Latest</a>
            </span>
        </div>
    </div>
    <script>
        // Detect base path from current URL (handles API Gateway stages and custom domains)
        function getBasePath() {
            const path = window.location.pathname;
            // If we're at /, base is empty (custom domain)
            // If we're at /prod/ or /stage/, extract the base (API Gateway)
            if (path === '/') {
                return '';
            }
            // Remove trailing slash to get the base path
            return path.replace(/\/$/, '');
        }

        function logViewer() {
            return {
                logs: [],
                loading: false,
                loadingOlder: false,
                loadingNewer: false,
                liveTailActive: false,
                liveTailInterval: null,
                searchQuery: '',
                searchDateTime: '',
                errorMessage: '',
                statusMessage: '',
                basePath: getBasePath(),
                isSearchMode: false,
                isDateTimeSearch: false,
                hasMoreSearchResults: false,
                searchContinuationCursor: '', // Cursor to continue batch searching
                searchStartTime: '',
                searchEndTime: '',
                lastScrollTop: 0,
                isProgrammaticScroll: false,
                wasLiveTailingBeforeHidden: false,
                debugEnabled: true, // Set to true to enable debug logging

                debug(message, data = null) {
                    if (this.debugEnabled) {
                        const now = new Date();
                        const timestamp = now.toLocaleTimeString('en-US', {
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        }) + '.' + String(now.getMilliseconds()).padStart(3, '0');

                        if (data !== null) {
                            console.log(`[${timestamp}] [TinyTail] ${message}`, data);
                        } else {
                            console.log(`[${timestamp}] [TinyTail] ${message}`);
                        }
                    }
                },

                init() {
                    this.debug('init() - Starting application');
                    this.startLiveTail();

                    // Handle tab visibility changes to save resources and ensure fresh data
                    document.addEventListener('visibilitychange', () => {
                        if (document.hidden) {
                            this.debug('Tab hidden - pausing live tail');
                            // Tab hidden - stop polling to save resources
                            if (this.liveTailActive) {
                                this.stopLiveTail();
                                this.wasLiveTailingBeforeHidden = true;
                            }
                        } else {
                            this.debug('Tab visible - resuming live tail');
                            // Tab visible again - resume and fetch fresh data
                            if (this.wasLiveTailingBeforeHidden) {
                                this.wasLiveTailingBeforeHidden = false;
                                this.startLiveTail(); // Will immediately fetch fresh logs
                            }
                        }
                    });
                },

                async loadLatestLogs() {
                    const isFirstLoad = this.logs.length === 0;
                    this.loading = isFirstLoad; // Only show loading if no logs yet
                    this.errorMessage = '';

                    try {
                        let url;
                        if (isFirstLoad) {
                            url = `${this.basePath}/logs/latest?limit=200`;
                        }
                        else {
                            const newestCursor = this.logs[this.logs.length - 1].cursor;
                            url = `${this.basePath}/logs?limit=200&after=${newestCursor}`;
                        }

                        const response = await fetch(url);
                        if (response.status === 302 || response.redirected) {
                            window.location.href = `${this.basePath}/login`;
                            return;
                        }
                        if (!response.ok) throw new Error('Failed to load logs');

                        let data = await response.json();
                        if ((!this.liveTailActive && !isFirstLoad) || this.isSearchMode) {
                            return;
                        }

                        // Update timestamp on every poll, even if no new logs
                        this.statusMessage = `Last Updated: ${new Date().toLocaleTimeString('en-US', { hour12: false })}`;

                        if (data && data.length > 0) {
                            if (isFirstLoad) {
                                // First load uses /logs/latest which returns newest-first, so reverse
                                data.reverse();
                                this.logs = data;
                            }
                            else {
                                // Subsequent polls use /logs?after=X which returns chronological order (oldest-first)
                                // Append directly without reversing
                                this.logs = [...this.logs, ...data];
                            }

                            this.$nextTick(() => {
                                this.scrollToBottom();
                            });
                        }
                    }
                    catch (error) {
                        this.errorMessage = error.message;
                        this.statusMessage = 'Error loading logs';
                    }
                    finally {
                        this.loading = false;
                    }
                },

                async loadOlderLogs() {
                    this.debug('loadOlderLogs() - Called');
                    if (this.logs.length === 0 || this.loadingOlder) {
                        this.debug('loadOlderLogs() - Skipping (no logs or already loading)');
                        return;
                    }

                    const oldestCursor = this.logs[0].cursor;
                    this.debug('loadOlderLogs() - Loading before cursor:', oldestCursor);
                    this.loadingOlder = true;

                    // Remember scroll position
                    const container = this.$refs.logsContainer;
                    const oldScrollHeight = container.scrollHeight;

                    try {
                        const response = await fetch(`${this.basePath}/logs?limit=100&before=${oldestCursor}`);
                        if (!response.ok) throw new Error('Failed to load older logs');

                        let data = await response.json();
                        this.debug('loadOlderLogs() - Received:', data?.length);
                        if (data && data.length > 0) {
                            // Backend returns chronological order (oldest first) - no need to reverse
                            this.logs = [...data, ...this.logs];

                            // Maintain scroll position
                            this.$nextTick(() => {
                                const newScrollHeight = container.scrollHeight;
                                container.scrollTop = newScrollHeight - oldScrollHeight;
                            });
                        }
                    }
                    catch (error) {
                        this.debug('loadOlderLogs() - Error:', error.message);
                        this.errorMessage = error.message;
                    }
                    finally {
                        this.loadingOlder = false;
                    }
                },

                async loadOlderSearchResults() {
                    this.debug('loadOlderSearchResults() - Called');
                    if (this.loadingOlder || !this.hasMoreSearchResults) {
                        this.debug('loadOlderSearchResults() - Skipping');
                        return;
                    }

                    // Use continuation cursor if available (for batch searching), otherwise use oldest log cursor
                    const cursorToUse = this.searchContinuationCursor || (this.logs.length > 0 ? this.logs[0].cursor : '');
                    this.debug('loadOlderSearchResults() - Loading before cursor:', cursorToUse, '(continuation:', !!this.searchContinuationCursor, ')');
                    this.loadingOlder = true;

                    // Remember scroll position
                    const container = this.$refs.logsContainer;
                    const oldScrollHeight = container.scrollHeight;

                    try {
                        // Backend returns { logs: [], continuation_cursor: "" }
                        const response = await fetch(`${this.basePath}/logs/search?q=${encodeURIComponent(this.searchQuery)}&before=${cursorToUse}`);
                        if (!response.ok) {
                            throw new Error('Failed to load older search results');
                        }

                        const searchResponse = await response.json();
                        let data = searchResponse.logs || [];
                        const newCursor = searchResponse.continuation_cursor || '';
                        this.debug('loadOlderSearchResults() - Old cursor:', this.searchContinuationCursor);
                        this.debug('loadOlderSearchResults() - New cursor:', newCursor);
                        this.searchContinuationCursor = newCursor;
                        this.debug('loadOlderSearchResults() - Received', data?.length, 'results, continuation_cursor:', this.searchContinuationCursor);

                        if (data && data.length > 0) {
                            // If we got 101 results, there are more - trim to 100
                            if (data.length > 100) {
                                this.hasMoreSearchResults = true;
                                data = data.slice(0, 100);
                            } else if (this.searchContinuationCursor) {
                                // Batch limit reached without enough matches - can continue searching
                                this.hasMoreSearchResults = true;
                            } else {
                                this.hasMoreSearchResults = false;
                            }

                            data.reverse();

                            // Deduplicate by cursor before prepending
                            const existingCursors = new Set(this.logs.map(log => log.cursor));
                            const newLogs = data.filter(log => !existingCursors.has(log.cursor));
                            this.debug('loadOlderSearchResults() - After deduplication:', newLogs.length, 'new logs (filtered', data.length - newLogs.length, 'duplicates)');

                            // If we had 0 logs before, just set them; otherwise prepend
                            if (this.logs.length === 0) {
                                this.logs = newLogs;
                                // Scroll to bottom for first batch of results
                                this.$nextTick(() => {
                                    this.scrollToBottom();
                                });
                            } else {
                                this.logs = [...newLogs, ...this.logs];
                                // Maintain scroll position
                                this.$nextTick(() => {
                                    const newScrollHeight = container.scrollHeight;
                                    container.scrollTop = newScrollHeight - oldScrollHeight;
                                });
                            }
                        }
                        else {
                            // Got 0 results - check if we can continue searching
                            if (this.searchContinuationCursor) {
                                this.debug('loadOlderSearchResults() - No results in this batch, but can continue searching');
                                this.hasMoreSearchResults = true;
                            } else {
                                this.debug('loadOlderSearchResults() - No more results and no continuation cursor');
                                this.hasMoreSearchResults = false;
                            }
                        }
                    }
                    catch (error) {
                        this.debug('loadOlderSearchResults() - Error:', error.message);
                        this.errorMessage = error.message;
                    }
                    finally {
                        this.loadingOlder = false;
                    }
                },

                async loadOlderDateTimeLogs() {
                    this.debug('loadOlderDateTimeLogs() - Called');
                    if (this.logs.length === 0 || this.loadingOlder) {
                        this.debug('loadOlderDateTimeLogs() - Skipping');
                        return;
                    }

                    const oldestCursor = this.logs[0].cursor;
                    this.debug('loadOlderDateTimeLogs() - Loading before cursor:', oldestCursor);
                    this.loadingOlder = true;

                    // Remember scroll position
                    const container = this.$refs.logsContainer;
                    const oldScrollHeight = container.scrollHeight;

                    try {
                        const response = await fetch(`${this.basePath}/logs?limit=200&before=${oldestCursor}`);
                        if (!response.ok) {
                            throw new Error('Failed to load older logs');
                        }

                        let data = await response.json();
                        this.debug('loadOlderDateTimeLogs() - Received:', data?.length);

                        // Only append if we're still in datetime search mode (prevents race condition with Clear)
                        if (this.isDateTimeSearch && data && data.length > 0) {
                            // Backend returns chronological order (oldest first) - no need to reverse
                            this.logs = [...data, ...this.logs];

                            // Maintain scroll position
                            this.$nextTick(() => {
                                const newScrollHeight = container.scrollHeight;
                                container.scrollTop = newScrollHeight - oldScrollHeight;
                            });
                        }
                    }
                    catch (error) {
                        this.debug('loadOlderDateTimeLogs() - Error:', error.message);
                        this.errorMessage = error.message;
                    }
                    finally {
                        this.loadingOlder = false;
                    }
                },

                async loadNewerDateTimeLogs() {
                    this.debug('loadNewerDateTimeLogs() - Called');
                    if (this.logs.length === 0 || this.loadingNewer || this.loading) {
                        this.debug('loadNewerDateTimeLogs() - Skipping');
                        return;
                    }

                    const newestCursor = this.logs[this.logs.length - 1].cursor;
                    this.debug('loadNewerDateTimeLogs() - Loading after cursor:', newestCursor);
                    this.loadingNewer = true;

                    try {
                        const response = await fetch(`${this.basePath}/logs?limit=200&after=${newestCursor}`);
                        if (!response.ok) {
                            throw new Error('Failed to load newer logs');
                        }

                        let data = await response.json();
                        this.debug('loadNewerDateTimeLogs() - Received:', data?.length);

                        if (this.isDateTimeSearch && data && data.length > 0) {
                            this.logs = [...this.logs, ...data];
                        }
                        else if (this.isDateTimeSearch && (!data || data.length === 0)) {
                            this.debug('loadNewerDateTimeLogs() - No more newer logs, switching to live tail');
                            this.searchDateTime = '';
                            this.isSearchMode = false;
                            this.isDateTimeSearch = false;
                            this.logs = []; // Clear old search results
                            this.startLiveTail();
                        }
                    }
                    catch (error) {
                        this.debug('loadNewerDateTimeLogs() - Error:', error.message);
                        this.errorMessage = error.message;
                    }
                    finally {
                        this.loadingNewer = false;
                    }
                },

                async performSearch() {
                    if (this.loading) {
                        this.debug('performSearch() - Already loading, ignoring');
                        return;
                    }

                    this.debug('performSearch() - Stopping live tail');
                    this.stopLiveTail();
                    this.isSearchMode = true;
                    this.isDateTimeSearch = false;

                    if (!this.searchQuery && !this.searchDateTime) {
                        this.debug('performSearch() - No search query or datetime, starting live tail');
                        this.isSearchMode = false;
                        this.isDateTimeSearch = false;
                        this.startLiveTail();
                        return;
                    }

                    this.loading = true;
                    this.errorMessage = '';
                    this.hasMoreSearchResults = false;

                    try {
                        let data;
                        let targetTimestamp = null;

                        if (this.searchDateTime) {
                            this.debug('performSearch() - DateTime search for:', this.searchDateTime);
                            this.isDateTimeSearch = true;
                            targetTimestamp = new Date(this.searchDateTime).toISOString();

                            this.debug('performSearch() - Fetching datetime logs');
                            const response = await fetch(`${this.basePath}/logs/datetime?timestamp=${encodeURIComponent(targetTimestamp)}`);
                            if (!response.ok) {
                                throw new Error('Search failed');
                            }
                            data = await response.json();

                            this.debug('performSearch() - Received datetime results:', data?.length);
                            const displayTime = new Date(this.searchDateTime).toLocaleString('en-US', { hour12: false });
                            this.statusMessage = `Found ${data?.length || 0} logs around ${displayTime}`;
                        }
                        else {
                            this.debug('performSearch() - Text search for:', this.searchQuery);
                            // Backend returns { logs: [], continuation_cursor: "" }
                            const response = await fetch(`${this.basePath}/logs/search?q=${encodeURIComponent(this.searchQuery)}`);
                            if (!response.ok) {
                                throw new Error('Search failed');
                            }
                            const searchResponse = await response.json();
                            data = searchResponse.logs || [];
                            this.searchContinuationCursor = searchResponse.continuation_cursor || '';
                            this.debug('performSearch() - Received', data?.length, 'results, continuation_cursor:', this.searchContinuationCursor);

                            // If we got 101 results, there are more - trim to 100
                            if (data && data.length > 100) {
                                this.hasMoreSearchResults = true;
                                data = data.slice(0, 100);
                            } else if (this.searchContinuationCursor) {
                                // Batch limit reached without enough matches - can continue searching
                                this.hasMoreSearchResults = true;
                            } else {
                                this.hasMoreSearchResults = false;
                            }

                            const resultCount = data?.length || 0;
                            const moreMsg = this.hasMoreSearchResults ? ' (scroll up for more)' : '';
                            this.statusMessage = `Found ${resultCount} results${moreMsg}`;
                            if (data && data.length > 0) {
                                data.reverse();
                            }
                        }

                        // Only update logs if live tail hasn't been restarted (prevents race with Clear button)
                        this.debug('performSearch() - Checking liveTailActive:', this.liveTailActive);
                        if (this.liveTailActive) {
                            this.debug('performSearch() - Live tail is active, ignoring search results');
                            return;
                        }

                        this.debug('performSearch() - Setting logs array, length:', data?.length);
                        this.logs = data || [];

                        // Scroll based on search type
                        this.$nextTick(() => {
                            // Set flag to ignore the scroll event from programmatic scrolling
                            this.isProgrammaticScroll = true;

                            if (targetTimestamp && this.logs.length > 0) {
                                // For datetime search, scroll to the log closest to target time
                                this.scrollToClosestLog(targetTimestamp);
                            }
                            else {
                                // For text search, scroll to bottom
                                this.scrollToBottom();
                            }
                        });
                    }
                    catch (error) {
                        this.errorMessage = error.message;
                        this.statusMessage = 'Error searching logs';
                    }
                    finally {
                        this.loading = false;
                    }
                },

                clearSearch() {
                    this.debug('clearSearch() - Called');

                    this.searchQuery = '';
                    this.searchDateTime = '';
                    this.isSearchMode = false;
                    this.isDateTimeSearch = false;
                    this.logs = [];

                    this.startLiveTail();
                },

                searchByTimestamp(timestamp) {
                    this.debug('searchByTimestamp() - Called with timestamp:', timestamp);

                    // Convert ISO timestamp to datetime-local format (YYYY-MM-DDTHH:mm)
                    const date = new Date(timestamp);
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    const formattedDateTime = `${year}-${month}-${day}T${hours}:${minutes}`;
                    this.debug('searchByTimestamp() - Formatted datetime:', formattedDateTime);

                    this.searchQuery = '';
                    this.searchDateTime = formattedDateTime;

                    this.performSearch();
                },

                handleScroll() {
                    // Ignore programmatic scrolls (from search positioning)
                    if (this.isProgrammaticScroll) {
                        this.debug('handleScroll() - Ignoring programmatic scroll');
                        this.isProgrammaticScroll = false;
                        return;
                    }

                    const container = this.$refs.logsContainer;
                    const currentScrollTop = container.scrollTop;
                    const atBottom = this.isScrolledToBottom();
                    const scrollingUp = currentScrollTop < this.lastScrollTop;
                    const scrollingDown = currentScrollTop > this.lastScrollTop;
                    const nearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
                    const isFirstScroll = this.lastScrollTop === 0 && currentScrollTop > 0;

                    if (!isFirstScroll && scrollingUp && currentScrollTop < 100 && !this.loadingOlder && this.logs.length > 0) {
                        if (this.isDateTimeSearch) {
                            // In datetime search mode: load older logs
                            this.loadOlderDateTimeLogs();
                        }
                        else if (this.isSearchMode) {
                            // In text search mode: load older search results if available
                            this.loadOlderSearchResults();
                        }
                        else {
                            // In normal mode: load older logs
                            this.loadOlderLogs();
                        }
                    }

                    // Handle scrolling down to load newer logs (only for datetime search, and not on first scroll)
                    if (!isFirstScroll && this.isDateTimeSearch && scrollingDown && nearBottom && !this.loadingNewer) {
                        this.debug('handleScroll() - Near bottom in datetime search, calling loadNewerDateTimeLogs');
                        this.loadNewerDateTimeLogs();
                    }

                    this.lastScrollTop = currentScrollTop;

                    // Only pause live tail if user actively scrolled UP (and not in search mode)
                    // Don't pause just from being not-at-bottom (could be from DOM changes)
                    if (!this.isSearchMode) {
                        if (scrollingUp && !atBottom && this.liveTailActive) {
                            this.debug('handleScroll() - User scrolled up, stopping live tail');
                            this.stopLiveTail();
                        }
                        else if (atBottom && !this.liveTailActive) {
                            this.debug('handleScroll() - Scrolled to bottom, starting live tail');
                            this.startLiveTail();
                        }
                    }
                },

                isScrolledToBottom() {
                    const container = this.$refs.logsContainer;
                    if (!container) return true;
                    const threshold = 100; // pixels from bottom
                    return container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
                },

                scrollToBottom() {
                    const container = this.$refs.logsContainer;
                    if (container) {
                        container.scrollTop = container.scrollHeight;
                    }
                },

                scrollToClosestLog(targetTimestamp) {
                    const container = this.$refs.logsContainer;
                    if (!container || this.logs.length === 0) {
                        return;
                    }

                    const targetTime = new Date(targetTimestamp).getTime();

                    let closestIndex = 0;
                    let smallestDiff = Math.abs(new Date(this.logs[0].timestamp).getTime() - targetTime);

                    for (let i = 1; i < this.logs.length; i++) {
                        const diff = Math.abs(new Date(this.logs[i].timestamp).getTime() - targetTime);
                        if (diff < smallestDiff) {
                            smallestDiff = diff;
                            closestIndex = i;
                        }
                    }

                    // Get all log entry elements
                    const logEntries = container.querySelectorAll('.log-entry');
                    if (logEntries.length > closestIndex) {
                        const targetElement = logEntries[closestIndex];

                        // Calculate position to center the element
                        const elementTop = targetElement.offsetTop;
                        const elementHeight = targetElement.offsetHeight;
                        const containerHeight = container.clientHeight;

                        // Scroll to center the element in the viewport
                        container.scrollTop = elementTop - (containerHeight / 2) + (elementHeight / 2);
                    }
                },

                startLiveTail() {
                    this.debug('startLiveTail() - Called, liveTailActive before:', this.liveTailActive);
                    if (this.liveTailActive) {
                        this.debug('startLiveTail() - Already active, returning');
                        return;
                    }

                    this.debug('startLiveTail() - Activating live tail');
                    this.liveTailActive = true;
                    this.loadLatestLogs();
                    this.liveTailInterval = setInterval(() => {
                        this.loadLatestLogs();
                    }, 3000);
                },

                stopLiveTail() {
                    this.debug('stopLiveTail() - Called');
                    this.liveTailActive = false;
                    if (this.liveTailInterval) {
                        clearInterval(this.liveTailInterval);
                        this.liveTailInterval = null;
                    }
                },

                async logout() {
                    try {
                        await fetch(`${this.basePath}/auth/logout`, { method: 'POST' });
                        window.location.href = `${this.basePath}/login`;
                    }
                    catch (error) {
                        this.errorMessage = 'Logout failed';
                    }
                },

                formatTimestamp(timestamp) {
                    // Format as "Nov 08 HH:MM:SS"
                    const date = new Date(timestamp);
                    const month = date.toLocaleDateString('en-US', { month: 'short' });
                    const day = String(date.getDate()).padStart(2, '0');
                    const time = date.toLocaleTimeString('en-US', {
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    return `${month} ${day} ${time}`;
                },

                abbreviateLogger(logger) {
                    if (!logger) {
                        return '';
                    }

                    // Split by dots: org.springframework.data.SomeClass
                    const parts = logger.split('.');

                    // If only one part (no package), return as-is
                    if (parts.length <= 1) {
                        return logger;
                    }

                    // Abbreviate all parts except the last one
                    const abbreviated = parts.slice(0, -1).map(part => part.charAt(0)).join('.');
                    const className = parts[parts.length - 1];

                    return abbreviated + '.' + className;
                },

                getContinuationTimestamp() {
                    if (!this.searchContinuationCursor) {
                        return '';
                    }

                    try {
                        // ULID format: first 10 characters are base32-encoded timestamp
                        const ulidTimePart = this.searchContinuationCursor.substring(0, 10);

                        // Base32 alphabet used by ULID (Crockford's base32)
                        const base32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';

                        // Decode base32 to get milliseconds since epoch
                        let timestamp = 0;
                        for (let i = 0; i < ulidTimePart.length; i++) {
                            const char = ulidTimePart[i];
                            const value = base32.indexOf(char);
                            if (value === -1) return '';
                            timestamp = timestamp * 32 + value;
                        }

                        // Format the timestamp
                        const date = new Date(timestamp);
                        return this.formatTimestamp(date.toISOString());
                    } catch (e) {
                        return '';
                    }
                }
            };
        }
    </script>
</body>
</html>